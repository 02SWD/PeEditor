// EncryptingShell.cpp: implementation of the EncryptingShell class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "EncryptingShell.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//函数声明
int aesEncryptApp(IN LPVOID plainText, IN DWORD sizeOfPlainText, OUT LPVOID* cipherText, OUT PDWORD sizeOfCipherText);

/**
 * 加壳
 * @param  shellSourcePath 壳源程序路径
 * @param  appPath         待被加壳的应用程序路径
 * @return                  1 - 加壳成功
 *                         -1 - 加壳失败 - 壳源或待加密程序读取失败
 *                         -2 - 加壳失败 - 待加密程序aes加密失败
 *                         -3 - 加壳失败 - 待加密程序加密后，添加到新增节中失败
 *                         -4 - 加壳失败 - 将加壳后的数据写出失败
 */
int EncryptShell(char* shellSourcePath, char* appPath){
	//1. 读取 壳源shellSourceFile 和 待加壳appFile 程序
	FILEINFOR shellSourceFile, appFile;
	shellSourceFile = readFile(shellSourcePath);
	appFile = readFile(appPath);
	if (shellSourceFile.p == NULL || appFile.p == NULL){
		return -1;
	}

	//2. 将待加壳程序数据进行aes加密
	//指向加密后的密文
	LPVOID cipherText = NULL;
	//密文的大小
	DWORD sizeOfCipherText = 0;
	//开始今次那个aes加密
	int aesFlag = aesEncryptApp(appFile.p, appFile.size, &cipherText, &sizeOfCipherText);
	if (aesFlag != 1){
		free(shellSourceFile.p);
		free(appFile.p);
		return -2;
	}

	//3. 令壳源的FileBuffer新增一个节，新增节的大小即为密文数据的大小
	//指向新增节后的新壳源FileBuffer
	LPVOID shellSourceOfNewFileBuffer = NULL;
	//记录 新壳源FileBuffer 的大小
	DWORD sizeShellSourceOfNewFileBuffer = 0;
	//记录 新壳源FileBuffer 中新节的FOA
	DWORD newSecFoaOfnewFileBuffer = 0;
	//进行新增节
	newSecFoaOfnewFileBuffer = increaseSection(shellSourceFile.p, sizeOfCipherText, &shellSourceOfNewFileBuffer, &sizeShellSourceOfNewFileBuffer);
	if (newSecFoaOfnewFileBuffer < 0){
		free(shellSourceFile.p);
		free(appFile.p);
		free(cipherText);
		return -3;
	}

	//4. 将 密文数据 复制到 壳源FileBuffer的新增节中
	char* des = (char*)((DWORD)shellSourceOfNewFileBuffer + newSecFoaOfnewFileBuffer);
	char* src = (char*)cipherText;
	memcpy(des, src, sizeOfCipherText);
	
	//5. 拼接 加完壳之后 程序要存放的路径（存放路径 = 壳源程序的路径去掉".exe" + "_shell.exe"）
	char encryptedAppPathBuffer[MAX_PATH] = {0};
	memcpy(encryptedAppPathBuffer, shellSourcePath, strlen(shellSourcePath)+1);
	char* token = strtok(encryptedAppPathBuffer, ".");
	memset(&encryptedAppPathBuffer[strlen(token)+1], 0, MAX_PATH-strlen(token)+1);
	char* encryptedAppPath = strcat(encryptedAppPathBuffer, "_shell.exe");
	
	//6. 将加完壳的新程序写出
	FILEINFOR encryptedAppFile;
	encryptedAppFile.p = (char*)shellSourceOfNewFileBuffer;
	encryptedAppFile.size = sizeShellSourceOfNewFileBuffer;
	int flag = writeFile(encryptedAppPath, encryptedAppFile);
	if (flag != 1){
		free(shellSourceFile.p);
		free(appFile.p);
		free(cipherText);
		free(shellSourceOfNewFileBuffer);
		return -4;
	}

	//7. 释放资源
	free(shellSourceFile.p);
	free(appFile.p);
	free(cipherText);
	free(shellSourceOfNewFileBuffer);

	return 1;
}

/**
 * 
 * AES加密
 * @param  plainText        明文
 * @param  sizeOfPlainText  明文的大小
 * @param  cipherText       密文
 * @param  sizeOfCipherText 密文的大小
 * @return                  -1 加密失败
 *                           1 加密成功
 */
int aesEncryptApp(IN LPVOID plainText, IN DWORD sizeOfPlainText, OUT LPVOID* cipherText, OUT PDWORD sizeOfCipherText){
	//秘钥，根据实际情况自己定义，AES128 用16字节、AES192 用24字节、AES256 用32字节
    unsigned char key[32] = {
        0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46,
        0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46
    };
    //初始化向量, 固定长度16个, 当mode=AES_MODE_CBC时用到
    unsigned char IV[4*Nb] = {0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46};
		
	unsigned char aesInfoAll[264] = {0x20, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0xFF, 0x19, 0x00, 0xF4, 0xFE, 0x19, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xFF, 0x19, 0x00, 0xB9, 0x2B, 0x40, 0x00, 0x01, 0x00, 0x00, 0x00, 0x38, 0x1A, 0x7D, 0x00, 0x90, 0x1A, 0x7D, 0x00, 0xD0, 0x2A, 0x40, 0x00, 0xD0, 0x2A, 0x40, 0x00, 0x00, 0x30, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0xFF, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xFF, 0x19, 0x00, 0x40, 0x5C, 0x40, 0x00, 0x30, 0x34, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0x19, 0x00, 0x59, 0x63, 0x7B, 0x75, 0x00, 0x30, 0x34, 0x00, 0x40, 0x63, 0x7B, 0x75, 0xDC, 0xFF, 0x19, 0x00, 0x26, 0xE6, 0x50, 0xB2, 0x13, 0xD0, 0x67, 0x8A, 0x2A, 0xE0, 0x26, 0xC8, 0x69, 0xA4, 0x63, 0x8E, 0xC8, 0x7B, 0xC8, 0x2D, 0xFD, 0x4D, 0xFF, 0x15, 0xC4, 0x7D, 0xBE, 0x57, 0x87, 0x39, 0xFB, 0x11, 0x4B, 0xF5, 0x37, 0xDD, 0x4B, 0xF5, 0x37, 0xDD, 0x4B, 0xF5, 0x37, 0xDD, 0x3B, 0x0A, 0x2E, 0xDD, 0x82, 0x21, 0x6E, 0xDD, 0x83, 0x21, 0x6E, 0xDD, 0xBB, 0x3B, 0x13, 0xDD, 0x2B, 0x21, 0x6E, 0xDD, 0xFB, 0x0B, 0x2E, 0xDD, 0x2B, 0x21, 0x6E, 0xDD, 0x2B, 0x11, 0x5A, 0xDD, 0x2B, 0x11, 0x5A, 0xDD, 0x2B, 0x11, 0x5A, 0xDD, 0x6F, 0xEE, 0x43, 0xDD, 0x6F, 0xEE, 0x43, 0xDD, 0xA3, 0x11, 0x5A, 0xDD, 0xE3, 0x4D, 0x1A, 0xDD, 0xD3, 0x79, 0x58, 0xDD, 0xD3, 0x79, 0x58, 0xDD, 0x53, 0x86, 0x41, 0xDD};

	//设置加密方式、密匙
	AESInfo_t aesInfo;
	memcpy(&aesInfo, aesInfoAll, 264);
	aesInfo.type = AES256;
	aesInfo.mode = AES_MODE_CBC;
	aesInfo.key = key;
	aesInfo.pIV = IV;

	//要加密的内容
	unsigned char* source = (unsigned char*)plainText;
	//加密后的内容(
    unsigned char* encryptMsg = (unsigned char*)malloc((sizeOfPlainText/16)*16+16);
	if (encryptMsg ==NULL){
		return -1;
	}
	memset(encryptMsg, 0, (sizeOfPlainText/16)*16+16);
	
	//初始化
	//AESInit(&aesInfo);
	//加密
    unsigned int len = AESEncrypt(&aesInfo, source, encryptMsg, sizeOfPlainText);
	
	//将 密文数据 和 密文的大小传出
	*cipherText = encryptMsg;
	*sizeOfCipherText = len;
	return 1;
}


















